tokens:
  flare-red:
    network: flare
    address: 0xE38D92733203E6f93C634304b777490e67Dc4Bdf
  flare-blue:
    network: flare
    address: 0x40D44abeC30288BFcd400200BA65FBD05daA5321

orders:
  flare:
    orderbook: flare
    inputs:
      - token: flare-red
      - token: flare-blue
    outputs:
      - token: flare-red
      - token: flare-blue

scenarios:
  flare:
    bindings:
      orderbook-subparser: 0xFc6836F666C737AB7E6f3Bf72A27Dc0dd126c334

      amount-token: 0x40D44abeC30288BFcd400200BA65FBD05daA5321
      tranche-size-expr: '''no-growth'
      tranche-size-base: 0
      tranche-size-growth: 0

      # Needs to be set to market price at order add time.
      quote-token: 0xE38D92733203E6f93C634304b777490e67Dc4Bdf
      initial-io-ratio: 1e50

      # Relative distance from the midpoint for tranche 0.
      # E.g. 0.005 is 0.5% spread which means total spread is 1%.
      spread: 0.005
      io-ratio-expr: '''exponential-growth'
      # e.g. 0.5% per tranche
      io-ratio-growth: 0.005

      # 60 * 60 * 24
      seconds-per-tranche: 86400

      # After any trade happens we pause before recharging.
      # Delay is to observe market feedback to the previous trade, e.g. to
      # potentially offer the next tranche at a different price for some time
      # before recharging back to the previous price.
      # Too long and people could grief to stop recharging.
      # Too quick and it will be difficult to move between tranches.
      # The default here is 5 minutes (units are seconds) and probably never
      # needs to be changed.
      tranche-space-recharge-delay: 300

      # When a tranche is completely cleared, the next tranche MAY be jumped
      # into partially. For example, if tranches are 90% shy (i.e. 0.9) then
      # if a tranche is cleared completely then the next tranche will be
      # started at 10% of its maximum size. This means that the capital
      # requirements for the strategy to reprice itself as the market moves
      # are reduced.
      # This MUST be set to a value less than 1e18, else it will entirely
      # skip tranches.
      # Shyness MAY be set to 0, in which case every tranche will be fully
      # available as it is entered.
      tranche-space-shyness: 0.9

      # Minimum trade size, if you put in a trade for less than x% of a
      # tranche it wont clear.
      # Mitigates people pinging strat for dust orders to stop recharging.
      min-tranche-space-diff: 0.1

      # Snap to the nearest tranche to avoid dust issues at the edges, either
      # due to rounding in the evm or potentially malicious trades.
      # 0.01 is 1%
      tranche-space-snap-threshold: 0.01

    scenarios:
      prod:
        bindings:
          get-last-tranche: '''get-last-tranche-prod'
          set-last-tranche: '''set-last-tranche-prod'
          plottables: '''plottables-prod'
      test:
        runs: 10000
        bindings:
          get-last-tranche: '''get-last-tranche-test'
          set-last-tranche: '''set-last-tranche-test'
          plottables: '''plottables-test'
          max-test-tranche-space: 20
          test-last-update-time: 0
          test-now: 0

charts:

deployments:
  flare:
    scenario: flare.prod
    order: flare

---
#orderbook-subparser !The subparser for the Orderbook

#amount-token !The token that is the amount token for the strategy. This denominates tranche sizes.
#tranche-size-expr !The binding to get the tranche size for the current tranche space.
#tranche-size-base !Base tranche size is the size of the smallest tranche, denominated in output token.
#tranche-size-growth !The exponential growth factor of the size of each tranche. E.g. 0.01 is 1% output amount growth per tranche.

#quote-token !The token that is the quote token for the strategy.
#initial-io-ratio !The IO ratio that the strategy starts at. The quote token is the output so that the IO ratio looks like a CEX price.

#spread !The relative distance from the midpoint for tranche 0. E.g. 0.01 is 1% spread which means total spread is 2%.
#io-ratio-expr !The binding to get the IO ratio for the current tranche space.
#io-ratio-growth !The exponential growth factor of the IO ratio. E.g. 0.01 is 1% io-ratio growth per tranche.

#seconds-per-tranche !The duration in seconds that it takes to recharge a tranche.
#tranche-space-recharge-delay !The duration in seconds that no recharging occurs after a trade occurs.

#tranche-space-shyness !The shyness of the liquidity in tranches. E.g. 0.9 is 90% shy.

#min-tranche-space-diff !The minimum tranche space difference that is allowed per trade. Prevents dusting the strat to stop it recharging.
#tranche-space-snap-threshold !The threshold in tranche space to snap to the nearest tranche to avoid dust issues at the edges.

#get-last-trade-io-ratio-expr !The binding to get the last trade IO ratio and time.
#get-cost-basis-io-ratio-expr !The binding to get the cost basis IO ratio.
#get-current-time-expr !The binding to get the current time.
#get-last-trade-time-expr !The binding to get the last trade time.
#get-last-tranche-space-expr !The binding to get the last tranche space and update time.
#set-last-tranche !The binding to set the last tranche space and update time.
#plottables !The binding for additional things we want to plot during testing.

#max-test-tranche-space !The maximum tranche space that will appear on the test chart.
#test-tranche-space-before !Returned by get-test-last-tranche to allow the tranche space before to be bound for testing.
#test-last-update-time !Returned by get-test-last-tranche to allow the last update time to be bound for testing.
#test-now !Returned by get-test-last-tranche to allow the current time to be bound for testing.

#last-trade-io-ratio-key "last-io-ratio"
#last-trade-time-key "last-trade-time"
#tranche-space-key "tranche-space"

/* Initialize new order */

#handle-add-order
  :set(hash(order-hash() last-trade-io-ratio-key) initial-io-ratio),
  :set(hash(order-hash() last-trade-time-key) now());

/* Calculate IO */

#calculate-io
  using-words-from orderbook-subparser
  current-tranche-floor
  current-tranche-headroom
  tranche-total-size:
    call<'calculate-tranche>(),
  tranche-io-ratio: call<'calculate-io-ratio>(current-tranche-floor),
  amount: call<'calculate-amount>(current-tranche-headroom tranche-total-size tranche-io-ratio),
  io-ratio: tranche-io-ratio,
  :call<'set-last-trade-io-ratio-expr>(io-ratio),
  :call<'set-last-trade-time-expr>(),
  :call<'plottables>(amount io-ratio);

#calculate-tranche
  last-tranche-space: call<'get-last-tranche-space-expr>(),
  last-trade-time: call<'get-last-trade-time-expr>(),
  current-time: call<'get-current-time-expr>(),
  recharge-duration: saturating-sub(current-time add(last-trade-time tranche-space-recharge-delay)),
  recharged-tranche-space: div(recharge-duration seconds-per-tranche),
  tranche-space-now: saturating-sub(last-tranche-space recharged-tranche-space),
  current-tranche-floor: floor(tranche-space-now),
  current-tranche-headroom: headroom(tranche-space-now),
  tranche-total-size: call<tranche-size-expr>(tranche-size-base tranche-size-growth current-tranche-floor);

#amount-is-output
  _: equal-to(amount-token output-token());

#calculate-amount
  current-tranche-headroom
  tranche-total-size
  tranche-io-ratio:,
  amount-available: mul(tranche-total-size current-tranche-headroom),
  _: if(call<'amount-is-output>() amount-available div(amount-available tranche-io-ratio));

#calculate-io-ratio
  current-tranche-floor:,
  midpoint: any(
    call<'get-cost-basis-io-ratio-expr>()
    call<'get-last-trade-io-ratio-expr>()
  ),
  io-ratio-base: mul(midpoint add(1 spread)),
  _: call<'io-ratio-expr>(io-ratio-base io-ratio-growth current-tranche-floor);

#get-current-time-prod
  _: now();

#get-last-trade-io-ratio-prod
  _: get(hash(order-hash() last-trade-io-ratio-key));

#set-last-trade-io-ratio-prod
  io-ratio:,
  :set(hash(order-hash() last-trade-io-ratio-key) io-ratio);

#get-last-trade-time-prod
  _: get(hash(order-hash() last-trade-time-key));

#set-last-trade-time-prod
  :set(hash(order-hash() last-trade-time-key) now());

#get-last-tranche-space-prod
  _: get(hash(order-hash() tranche-space-key));

#set-last-tranche-space-prod
  tranche-space:,
  :set(hash(order-hash() tranche-space-key) tranche-space);

#get-cost-basis-io-ratio-prod
  total-in: get(hash(order-hash() input-token() output-token() input-token())),
  total-out: get(hash(order-hash() input-token() output-token() output-token())),
  _: div(total-in total-out);

#set-cost-basis-io-ratio-prod
  /* first reduce outstanding inventory */
  other-total-in-key: hash(order-hash() output-token() input-token() output-token()),
  other-total-out-key: hash(order-hash() output-token() input-token() input-token()),
  other-total-in: get(other-total-in-key),
  other-total-out: get(other-total-out-key),
  other-reduction-in: min(other-total-in output-vault-decrease()),
  :set(other-total-in-key sub(other-total-in other-reduction-in)),
  other-redution-out: div(mul(other-reduction-in other-total-out) other-total-in),
  :set(other-total-out-key sub(other-total-out other-redution-out)),
  /* then increase our inventory */
  total-in-key: hash(order-hash() input-token() output-token() input-token()),
  total-out-key: hash(order-hash() input-token() output-token() output-token()),
  total-in: get(total-in-key),
  total-out: get(total-out-key),
  remaining-out: sub(output-vault-decrease() other-reduction-in),
  remaining-in: div(mul(remaining-out total-in) total-out),
  :set(total-in-key add(total-in remaining-in)),
  :set(total-out-key add(total-out remaining-out));

/* Handle IO */

#handle-io
  tranche-space-before
  _
  _
  tranche-total-size: call<'calculate-tranche>(),
  tranche-amount-diff: if(
    call<'amount-is-output>()
    output-vault-decrease()
    input-vault-increase()
  ),
  tranche-space-diff: div(tranche-amount-diff tranche-total-size),
  tranche-space-after: add(tranche-space-before tranche-space-diff),
  /* Snap tranche space to the nearest tranche to avoid dust issues at the edges */
  tranche-space-after-snapped: snap-to-unit(tranche-space-snap-threshold tranche-space-after),
  shy-tranche-space: if(
    is-zero(frac(tranche-space-after-snapped))
    add(tranche-space-after-snapped tranche-space-shyness)
    tranche-space-after-snapped),
  :ensure(
    greater-than-or-equal-to(tranche-space-after-snapped add(tranche-space-before min-tranche-space-diff))
    "Minimum trade size not met."
  ),
  :call<'set-last-tranche-space-expr>(shy-tranche-space),
  :call<'set-cost-basis-io-ratio-expr>();

/* Growth functions */

#exponential-growth
  base rate t:,
  _: exponential-growth(base rate t);

#linear-growth
  base rate t:,
  _: linear-growth(base rate t);

#no-growth
  base _ _:,
  _: base;

/* Test bindings */

#plottables-test
  amount
  io-ratio:,
  input-amount: mul(amount io-ratio),
  effective-price: inv(io-ratio);

#plottables-prod
  amount
  io-ratio:;

#get-last-tranche-test
  tranche-space-before: mod(test-tranche-space-before max-test-tranche-space),
  last-update-time: test-last-update-time,
  current-time: test-now;

#set-last-tranche-test
  tranche-space current-time:;