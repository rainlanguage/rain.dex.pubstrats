raindex-version: test_sha

deployers:
  base:
    address: 0xC1A14cE2fd58A3A2f99deCb8eDd866204eE07f8D
    network: base

tokens:
  base-usdbc:
    network: base
    address: 0xd9aAEc86B65D86f6A7B5B1b0c42FFA531710b6CA
    decimals: 6
  base-usdc:
    network: base
    address: 0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913
    decimals: 6
  base-dai:
    network: base
    address: 0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb
    decimals: 18
  base-dola:
    network: base
    address: 0x4621b7A9c75199271F773Ebd9A499dbd165c3191
    decimals: 18

orders:
  base:
    orderbook: base
    inputs:
      - token: base-usdbc
      - token: base-usdc
      - token: base-dai
      - token: base-dola
    outputs:
      - token: base-usdbc
      - token: base-usdc
      - token: base-dai
      - token: base-dola

scenarios:
  base:
    orderbook: base
    runs: 1
    bindings:
      time-per-epoch-init: 3600
      initial-max-io: 1.1

      time-per-epoch-trading: 28800
      io-multiplier: 0.03

charts:
  base:

deployments:
  base:
    order: base
    scenario: base

---
#raindex-subparser 0x662dFd6d5B6DF94E07A60954901D3001c24F856a

#trade-time-ago-key "trade-time-ago-key"

#time-per-epoch-init !Number of seconds per epoch during initialization. An epoch is one halving.
#initial-max-io !A very large io that is the starting auction for pairs before any trades have happened.

#time-per-epoch-trading !Number of seconds per epoch during trading. An epoch is one halving.
#io-multiplier !Multiple of the breakeven io to start each flip at. E.g. 0.2 starts 20% above breakeven.

#handle-add-order
using-words-from
  raindex-subparser
  key:
    hash(order-hash() trade-time-ago-key),
  :set(key now());

#epochs-since-trade
time-per-epoch:,
key:
  hash(order-hash() trade-time-ago-key),
last-time: get(key),
time-ago:
  sub(now() last-time),
epochs:
  div(time-ago time-per-epoch),

:set(key now());

#halflife
max-io epochs:,
/**
 * Shrinking the multiplier like this
 * then applying it 10 times allows for
 * better precision when max-io-ratio
 * is very large, e.g. ~1e10 or ~1e20+
 *
 * This works because `power` loses
 * precision on base `0.5` when the
 * exponent is large and can even go
 * to `0` while the io-ratio is still
 * large. Better to keep the multiplier
 * higher precision and drop the io-ratio
 * smoothly for as long as we can.
 */
multiplier:
  power(0.5 div(epochs 10)),
io:
  mul(
    max-io
    multiplier
    multiplier
    multiplier
    multiplier
    multiplier
    multiplier
    multiplier
    multiplier
    multiplier
    multiplier
  );

#breakeven-io
prev-input-vault-balance:
  get(hash(order-hash() input-token())),
output-vault-balance: output-vault-before(),

/**
 * This will be `0` initially which is a dangerous edge case
 * as we will naively ask for `0` input and instantly lose
 * all our funds. This needs to be handled carefully.
 *
 * After at least one trade has occurred on this pair it will
 * never be `0` again and so is safe.
 */
io:
  div(prev-input-vault-balance output-vault-balance);

#calculate-io
using-words-from
  raindex-subparser

baseline-io:
  call<'breakeven-io>(),
max-additional-io:
  if(baseline-io mul(baseline-io io-multiplier) initial-max-io),
time-per-epoch:
  if(baseline-io time-per-epoch-trading time-per-epoch-init),
additional-io:
  call<'halflife>(max-additional-io call<'epochs-since-trade>(time-per-epoch)),
_: max-value(),
_: add(baseline-io additional-io);

#handle-io
  :ensure(output-vault-before() "No output."),
  :ensure(
    equal-to(output-vault-before() output-vault-decrease())
    "Partial clear."
  ),
  :set(
    hash(order-hash() output-token())
    output-vault-before()
  );